#include "onnx2cpp.h"
#include "Utils.h"
#include "OnnxConst.h"
#include "OnnxVar.h"
#include <iostream>
#include <fstream>
#include <onnx/common/file_utils.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>

#include <onnx/version_converter/convert.h>
#include <memory>
#include <vector>
using namespace toCpp;

onnx::ValueInfoProto makeValueInfoFromTensorProto(const onnx::TensorProto& tensorProto)
{
	onnx::ValueInfoProto valueInfo;
	valueInfo.set_name(tensorProto.name());
	valueInfo.mutable_type()->mutable_tensor_type()->set_elem_type(tensorProto.data_type());
	for (const auto& dim : tensorProto.dims()) {
		valueInfo.mutable_type()->mutable_tensor_type()->mutable_shape()->add_dim()->set_dim_value(dim);
	}
	return valueInfo;
}

bool load_input_data(const std::string& filename, onnx::TensorProto& result)
{
	/* TODO: read Protobuffers documentation. This is lifted from
	 * ONNX code - looks like there could be a more C++ way to do this */
	FILE* f = fopen(filename.c_str(), "rb");
	if (f == NULL)
		return false;
	fseek(f, 0, SEEK_END);
	int size = ftell(f);
	fseek(f, 0, SEEK_SET);

	std::vector<char> data(size); // Use std::vector for dynamic memory allocation
	int nread = fread(data.data(), 1, size, f); // Use data.data() to access the underlying array
	fclose(f);

	if (nread != size)
		throw std::runtime_error("Problem reading input data");

	::google::protobuf::io::ArrayInputStream input_stream(data.data(), size); // Use data.data() here as well
	::google::protobuf::io::CodedInputStream coded_stream(&input_stream);
	return result.ParseFromCodedStream(&coded_stream);
}

onnx::TensorProto get_inputProto_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return onnx::TensorProto();

	//std::unique_ptr<onnx::TensorProto> tensorPointer = std::make_unique<onnx::TensorProto>(tensor);
	return tensor;
}

std::unique_ptr<OnnxConst> get_inputConst_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return nullptr;

	std::unique_ptr<OnnxConst> tensorPointer = std::make_unique<OnnxConst>(tensor);
	return tensorPointer;
}

std::unique_ptr<OnnxVar> get_inputVar_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return nullptr;
	onnx::ValueInfoProto valueInfo = makeValueInfoFromTensorProto(tensor);
	std::unique_ptr<OnnxVar> valueInfoPointer = std::make_unique<OnnxVar>(valueInfo);
	return valueInfoPointer;
}

int main(int argc, char* argv[])
{
	if (argc < 5) {
		std::cerr << "Usage:" << std::endl;
		std::cerr << "./onnx_backend_tests_runner <directory> <absAccuracy> <relAccuracy> <test_data_set> <targetFile>" << std::endl;
		std::cerr << std::endl;
		std::cerr << " <directory> is the directory that contains the test - i.e. 'model.onnx' and test_data_set_0" << std::endl;
		std::cerr << " <absAccuracy> floating point value: the maximum allowed difference between result and refrence when one of them is zero. Use decimal dot, not comma! " << std::endl;
		std::cerr << " <relAccuracy> floating point value: the maximum allowed relative difference between result and refrence. Use decimal dot, not comma! " << std::endl;
		std::cerr << " <test_data_set> integer value: select the test dataset to run this test against. (Most tests have only 0)" << std::endl;
		std::cerr << " <targetFile> Path to target file" << std::endl;
		exit(1);
	}

	// Load the ONNX model
	std::string dir(argv[1]);
	float absAccuracy = std::stod(argv[2]);
	float relAccuracy = std::stod(argv[3]);
	int dataSet = std::stoi(argv[4]);
	std::string targetDir(argv[5]);
	onnx::ModelProto onnx_model;
	std::string model_fn = dir + "/model.onnx";
	std::fstream file;
	try {
		file.open(targetDir, std::ostringstream::out | std::ostringstream::trunc);
	}
	catch (const std::exception& e) {
		std::cerr << "Error opening target file: " << e.what() << std::endl;
		exit(1);
	}
	if (file.is_open() && file.good()) {
		file << "// Generated by onnx2cpp\n";
		file << "// Model: " << model_fn << "\n";
		file << "// Absolute Accuracy: " << absAccuracy << "\n";
		file << "// Relative Accuracy: " << relAccuracy << "\n";
		file << "// Test data set: " << dataSet << "\n";
	}
	else {
		std::cerr << "Error: Could not open file for writing: " << targetDir << std::endl;
		return 1; // Exit with error code
	}
	file << "#include <xtensor.hpp>\n";
	file << "#include \"dco.hpp\"\n";
	onnx::LoadProtoFromPath(model_fn, onnx_model);
	// convert Model to version supported by onnx2cpp
	onnx_model = onnx::version_conversion::ConvertVersion(onnx_model, 18);
	// Print testsuite to get executed by CTest
	std::vector<std::unique_ptr<OnnxConst>> inputs;
	std::vector<OnnxVar> outputs;
	std::vector<OnnxVar> references;
	std::vector<std::string> staticInputs;
	std::string dataset_dir = dir + "/test_data_set_" + std::to_string(dataSet);
	int input_number = 0;
	while (true) {
		std::string partial = dataset_dir + "/input_";
		std::unique_ptr<OnnxConst> in = get_inputConst_from_file(partial, input_number);
		if (in == nullptr)
			break;
		if (input_number != 0)
			staticInputs.push_back(in->Name());
		in->Name(in->Name() + "_graph_in");
		inputs.push_back(std::move(in));
		input_number++;
	}

	OnnxGraph tmpGraph = onnx2cpp::MakeCppFileGraphOut(onnx_model, file, staticInputs);
	std::string functionName = tmpGraph.Name();
	file << "// Compare dco results with finite diefference\n";
	input_number = 0;
	for (size_t i = 0; i < tmpGraph.GetOutputs().size(); ++i) {
		OnnxVar out = *(tmpGraph.GetOutputs()[i]);
		out.Name(out.Name() + "_graph_out");
		out.SetIO(false, false);
		outputs.push_back(out);
		OnnxVar ref = *(tmpGraph.GetOutputs()[i]);
		ref.Name(ref.Name() + "_reference");
		ref.SetIO(false, false);
		references.push_back(ref);
	}

	std::vector<std::string> inputNames;
	std::vector<std::string> ffInputNames; // finite forward input names
	std::vector<std::string> fbInputNames; // finite backward input names
	std::vector<std::string> functionInputNames;
	std::vector<std::string> outputNames;
	std::vector<std::string> ffOutputNames; // finite forward output names
	std::vector<std::string> fbOutputNames; // finite backward output names
	std::vector<std::string> functionOutputNames;
	std::vector<std::string> functionResNames;
	std::vector<std::string> referenceNames; // finite central reference names

	for (size_t i = 0; i < inputs.size(); ++i) {
		std::string inputName = inputs[i]->Name();
		inputNames.push_back(inputName);
		ffInputNames.push_back(inputName + "_finite_forward");
		fbInputNames.push_back(inputName + "_finite_backward");
		functionInputNames.push_back(inputName + "_v");
	}

	for (size_t i = 0; i < outputs.size(); ++i) {
		std::string outputName = outputs[i].Name();
		outputNames.push_back(outputName);
		ffOutputNames.push_back(outputName + "_finite_forward");
		fbOutputNames.push_back(outputName + "_finite_backward");
		functionOutputNames.push_back(outputName + "_v");
		functionResNames.push_back(outputName + "_df_dx");
	}
	for (size_t i = 0; i < references.size(); ++i) {
		referenceNames.push_back(references[i].Name());
	}

	// adjoint function
	file << "void df_fx_adjoint(";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << "const xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << functionInputNames[i];
		if (i < inputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> &" << functionOutputNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> &" << functionResNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ") {\n";
	// initialize dco variables
	file << "using T = dco::ga1s<float>::type;\n";
	file << "dco::smart_tape_ptr_t<dco::mode<T>> tape;\n";
	for (size_t i = 0; i < inputs.size(); ++i) {
		if (i == 0)
			file << "xt::xarray<T> " << inputNames[i] << " = xt::cast<T>(" << functionInputNames[i] << ");\n";
		else
			file << "auto " << inputNames[i] << " = " << functionInputNames[i] << ";\n";
	}
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString() << "> " << outputNames[i] << ";\n";
	}
	// Register input variables
	if (inputNames.size() >= 1) {
		file << "for(size_t i = 0; i < " << inputNames[0] << ".size(); i++){\n";
		file << "tape->register_variable(" << inputNames[0] << ".flat(i));\n";
		file << "}\n";
	}
	// Call the function with dco variables
	std::string hasInAndOut = "";
	if (!inputs.empty() && !outputs.empty()) {
		hasInAndOut = ", ";
	}
	file << functionName << "(" << Join(inputNames, ", ") << hasInAndOut << Join(outputNames, ", ") << "); \n";
	// Register output variables
	if (outputNames.size() >= 1) {
		file << "for(size_t i = 0; i < " << outputNames[0] << ".size(); i++){";
		file << "tape->register_output_variable(" << outputNames[0] << ".flat(i));\n";
		file << "}\n";
	}

	// propagate adjoint 
	
	for (size_t i = 0; i < outputNames.size(); ++i) {
		file << functionResNames[i] << " = xt::zeros<"+ outputs[i].GetDataTypeAsString(true) +">({";
		for (size_t j = 0; j < outputs[i].Shape().size(); ++j) {
			if (j > 0) {
				file << ", ";
			}
			file << outputs[i].Shape()[j];
		}
		file << "}); // Shape of outputs Tensor\n";
		file << "for(size_t k = 0; k < " << inputNames[i] << ".size(); k++){\n";
		file << "for(size_t i = 0; i < " << outputNames[i] << ".size(); i++){\n";
		file << "dco::derivative(" << outputNames[0] << ".flat(i)) = 1;\n";
		if (inputNames.size() >= 1) {
			file << "for(size_t j = 0; j < " << inputNames[0] << ".size(); j++){";
			file << "dco::derivative(" << inputNames[0] << ".flat(j)) = 0;\n";
			file << "}\n";
		}
		file << "tape->interpret_adjoint();\n";
		file << functionResNames[i] << ".flat(i) += dco::derivative(" << inputNames[i] << ".flat(k));\n";
		file << "tape->zero_adjoints();\n";
		file << "}\n";
		file << "}\n";

	}
	file << "}\n";

	// Main function
	file << "int main(void) {\n";
	file << "double h = 0.00001;\n";
	file << "// Graph inputs\n";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << inputs[i]->GetConstantString();
		// differentiate for first input parameter
		if (i == 0) {
			file << "xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << ffInputNames[i] << " = " << inputNames[i] << " + h; \n";
			file << "xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << fbInputNames[i] << " = " << inputNames[i] << " - h; \n";
		}
		else {
			file << "xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << ffInputNames[i] << " = " << inputNames[i] << "; \n";
			file << "xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << fbInputNames[i] << " = " << inputNames[i] << "; \n";
		}
	}
	file << "// Graph outputs\n";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << outputs[i].GetVariableString(true) + "\n";
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> " << ffOutputNames[i] << ";\n";
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> " << fbOutputNames[i] << ";\n";
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> " << functionResNames[i] << ";\n";
	}
	file << "// Reference Values\n";
	for (size_t i = 0; i < references.size(); ++i) {
		file << references[i].GetVariableString(true) << "\n";
	}
	hasInAndOut = "";
	if (!inputs.empty() && !outputs.empty()) {
		hasInAndOut = ", ";
	}

	file << functionName << "(" << Join(inputNames, ", ") << hasInAndOut << Join(outputNames, ", ") << "); \n";
	file << functionName << "(" << Join(ffInputNames, ", ") << hasInAndOut << Join(ffOutputNames, ", ") << "); \n";
	file << functionName << "(" << Join(fbInputNames, ", ") << hasInAndOut << Join(fbOutputNames, ", ") << "); \n";
	for (size_t i = 0; i < outputNames.size(); ++i) {
		if (i < referenceNames.size() && i < ffOutputNames.size()) {
			file << referenceNames[i] << " = (" << ffOutputNames[i] << " - " << fbOutputNames[i] << ")/(2 * h); \n"; // https://www.wias-berlin.de/people/john/LEHRE/NUM_PDE/SS09/num_pde_intro_02.pdf
		}
	}
	// tangent function call
	file << "df_fx_adjoint(";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << inputNames[i];
		if (i < inputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << outputNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << functionResNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << "); \n";

	// Compare Results
	for (size_t i = 0; i < outputNames.size(); ++i) {
		if (i < referenceNames.size()) {
			file << "if(" << functionResNames[i] << ".shape() !=" << referenceNames[i] << ".shape()){\n";
			file << "std::cout << \"Test failed because shape is not equal for function result shape " << functionResNames[i] << ".\\n Expected: \\n\" << xt::adapt(" << referenceNames[i] << ".shape()) << \"\\n Actual: \\n\" << xt::adapt(" << functionResNames[i] << ".shape()) << std::endl;";
			file << "return 1; \n";
			file << "}\n";
			file << "for(std::size_t i = 0; i < " << functionResNames[i] << ".size(); ++i){\n";
			file << "if(" << functionResNames[i] << ".flat(i) != 0 && " << referenceNames[i] << ".flat(i) != 0){\n";
			file << "if(std::abs( 1 - (" << functionResNames[i] << ".flat(i) / " << referenceNames[i] << ".flat(i))) > " << relAccuracy << "){\n";
			file << "std::cout << \"Test failed for output " << functionResNames[i] << ".\\n Expected: \\n\" << " << referenceNames[i] << " << \"\\n Actual: \\n\" << " << functionResNames[i] << " << std::endl;\n";
			file << "return 1; \n";
			file << "}\n";
			file << "}\n";
			file << "else{\n";
			file << "if(std::abs(" << functionResNames[i] << ".flat(i) - " << referenceNames[i] << ".flat(i)) > " << absAccuracy << "){\n";
			file << "std::cout << \"Test failed for output " << functionResNames[i] << ".\\n Expected: \\n\" << " << referenceNames[i] << " << \"\\n Actual: \\n\" << " << functionResNames[i] << " << std::endl;\n";
			file << "return 1; \n";
			file << "}\n";
			file << "}\n";
			file << "}\n";

		}
	}
	file << "std::cout << \"Test passed!\" << std::endl;\n";
	file << "return 0;\n";
	file << "}\n";

	file.close();

}
