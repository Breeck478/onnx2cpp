#include "onnx2cpp.h"
#include "Utils.h"
#include "OnnxConst.h"
#include "OnnxVar.h"
#include <iostream>

#include <fstream>
#include <onnx/common/file_utils.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <memory>
#include <vector>
using namespace toCpp;

onnx::ValueInfoProto makeValueInfoFromTensorProto(const onnx::TensorProto& tensorProto)
{
	onnx::ValueInfoProto valueInfo;
	valueInfo.set_name(tensorProto.name());
	valueInfo.mutable_type()->mutable_tensor_type()->set_elem_type(tensorProto.data_type());
	for (const auto& dim : tensorProto.dims()) {
		valueInfo.mutable_type()->mutable_tensor_type()->mutable_shape()->add_dim()->set_dim_value(dim);
	}
	return valueInfo;
}

bool load_input_data(const std::string& filename, onnx::TensorProto& result)
{
   /* TODO: read Protobuffers documentation. This is lifted from
    * ONNX code - looks like there could be a more C++ way to do this */
   FILE* f = fopen(filename.c_str(), "rb");
   if (f == NULL)
       return false;
   fseek(f, 0, SEEK_END);
   int size = ftell(f);
   fseek(f, 0, SEEK_SET);

   std::vector<char> data(size); // Use std::vector for dynamic memory allocation
   int nread = fread(data.data(), 1, size, f); // Use data.data() to access the underlying array
   fclose(f);

   if (nread != size)
	   throw std::runtime_error("Problem reading input data");

   ::google::protobuf::io::ArrayInputStream input_stream(data.data(), size); // Use data.data() here as well
   ::google::protobuf::io::CodedInputStream coded_stream(&input_stream);
   return result.ParseFromCodedStream(&coded_stream);
}

onnx::TensorProto get_inputProto_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return onnx::TensorProto();

	//std::unique_ptr<onnx::TensorProto> tensorPointer = std::make_unique<onnx::TensorProto>(tensor);
	return tensor;
}

std::unique_ptr<OnnxConst> get_inputConst_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return nullptr;

	std::unique_ptr<OnnxConst> tensorPointer = std::make_unique<OnnxConst>(tensor);
	return tensorPointer;
}

std::unique_ptr<OnnxVar> get_inputVar_from_file(std::string& partial_path, int input_number)
{
	onnx::TensorProto tensor;
	std::string input_fn = partial_path + std::to_string(input_number) + ".pb";

	if (load_input_data(input_fn, tensor) == false)
		return nullptr;
	onnx::ValueInfoProto valueInfo = makeValueInfoFromTensorProto(tensor);
	std::unique_ptr<OnnxVar> valueInfoPointer = std::make_unique<OnnxVar>(valueInfo);
	return valueInfoPointer;
}

int main(int argc, char* argv[])
{
	if (argc < 5) {
		std::cerr << "Usage:" << std::endl;
		std::cerr << "./onnx_backend_tests_runner <directory> <accuracy> <test_data_set> <targetFile>" << std::endl;
		std::cerr << std::endl;
		std::cerr << " <directory> is the directory that contains the test - i.e. 'model.onnx' and test_data_set_0" << std::endl;
		std::cerr << " <accuracy> floating point value: the maximum allowed difference between result and refrence. Use decimal dot, not comma!" << std::endl;
		std::cerr << " <test_data_set> integer value: select the test dataset to run this test against. (Most tests have only 0)" << std::endl;
		std::cerr << " <targetFile> Path to target file" << std::endl;
		exit(1);
	}

	// Load the ONNX model
	float accuracy = std::stod(argv[2]);
	onnx::ModelProto onnx_model;
	std::string dir(argv[1]);
	std::string targetDir(argv[4]);
	std::string model_fn = dir + "/model.onnx";
	std::fstream file;
	try {
		file.open(targetDir, std::ostringstream::out | std::ostringstream::trunc);	
	} catch (const std::exception& e) {
		std::cerr << "Error opening target file: " << e.what() << std::endl;
		exit(1);
	}
	if (file.is_open() && file.good()) {
		file << "// Generated by onnx2cpp\n";
		file << "// Model: " << model_fn << "\n";
		file << "// Accuracy: " << accuracy << "\n";
		file << "// Test data set: " << argv[3] << "\n";
	}
	else {
		std::cerr << "Error: Could not open file for writing: " << targetDir << std::endl;
		return 1; // Exit with error code
	}
	file << "#include <xtensor.hpp>\n";
	file << "#include \"dco.hpp\"\n";
	onnx::LoadProtoFromPath(model_fn, onnx_model);
	OnnxGraph tmpGraph = OnnxGraph();
	// Print model to file specified by cmake
	std::string functionName = onnx2cpp::MakeCppFile(onnx_model, file, false, tmpGraph);
	// Print testsuite to get executed by CTest
	std::vector<std::unique_ptr<OnnxConst>> inputs;
	std::vector<OnnxVar> outputs;
	std::vector<OnnxVar> references;
	std::string dataset_dir = dir + "/test_data_set_" + argv[3];
	int input_number = 0;
	while (true) {
		std::string partial = dataset_dir + "/input_";
		std::unique_ptr<OnnxConst> in = get_inputConst_from_file(partial, input_number);
		if (in == nullptr)
			break;
		in->Name(in->Name() + "_graph_in");
		inputs.push_back(std::move(in));
		input_number++;
	}
	file << "// Compare dco results with finite diefference\n";	
	input_number = 0;
	for (size_t i = 0; i < tmpGraph.GetOutputs().size(); ++i) {
		OnnxVar out = *(tmpGraph.GetOutputs()[i]);
		out.Name(out.Name() + "_graph_out");
		out.SetIO(false, false);
		outputs.push_back(out);
		OnnxVar ref = *(tmpGraph.GetOutputs()[i]);
		ref.Name(ref.Name() + "_reference");
		ref.SetIO(false, false);
		references.push_back(ref);
	}

	std::vector<std::string> inputNames;
	std::vector<std::string> finiteInputNames;
	std::vector<std::string> functionInputNames;
	std::vector<std::string> outputNames;
	std::vector<std::string> finiteOutputNames;
	std::vector<std::string> functionOutputNames;
	std::vector<std::string> functionResNames;
	std::vector<std::string> referenceNames;
	for (size_t i = 0; i < inputs.size(); ++i) {
		inputNames.push_back(inputs[i]->Name());
		finiteInputNames.push_back(inputs[i]->Name() + "_finite");
		functionInputNames.push_back(inputs[i]->Name() + "_v");
	}

	for (size_t i = 0; i < outputs.size(); ++i) {
		outputNames.push_back(outputs[i].Name());
		finiteOutputNames.push_back(outputs[i].Name() + "_finite");
		functionOutputNames.push_back(outputs[i].Name() + "_v");
		functionResNames.push_back(outputs[i].Name() + "_df_dx");
	}
	for (size_t i = 0; i < references.size(); ++i) {
		referenceNames.push_back(references[i].Name());
	}
	// make helper function for appending xarray
	file << "template <typename T>\n";
	file << "xt::xarray<T> appendValue(const xt::xarray<T> &arr, T val)\n";
	file << "{\n";
	file << "xt::xarray<T> new_arr = xt::empty<T>({ arr.size() + 1 });\n";
	file << "std::copy(arr.begin(), arr.end(), new_arr.begin());\n";
	file << "new_arr(arr.size()) = val; // letzten Wert setzen\n";
	file << "return new_arr;\n";
	file << "}\n";

	// tangent function
	file << "void df_fx_tangent(";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << "const xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << functionInputNames[i];
		if (i < inputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> &" << functionOutputNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> &" << functionResNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ") {\n";
	// initialize dco variables
	file << "using T = dco::gt1s<float>::type;\n";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << "xt::xarray<T> " << inputNames[i] << " = xt::cast<T>(" << functionInputNames[i] << ");\n";
	}
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << "xt::xarray<T> " << outputNames[i] << ";\n";
	}
	for (size_t i = 0; i < inputNames.size(); ++i) {
		file << "for(size_t i = 0; i < "<< inputNames[i] << ".size(); i++){"  ;
		file << "dco::derivative(" << inputNames[i] << ".flat(i)) = 1;\n";
		file << "}\n";
	}
	// Call the function with dco variables
	std::string hasInAndOut = "";
	if (!inputs.empty() && !outputs.empty()) {
		hasInAndOut = ", ";
	}
	file << functionName << "(" << join(inputNames, ", ") << hasInAndOut << join(outputNames, ", ") << "); \n";
	for (size_t i = 0; i < outputNames.size(); ++i) {
		file << "for(size_t i = 0; i < " << outputNames[i] << ".size(); i++){\n";
		file << "if (i == 0){\n";
		file << functionResNames[i] << ".data()[i] = dco::derivative(" << outputNames[i] << ".flat(i));\n";
		file << "} else {\n";
		file << functionResNames[i] << " = appendValue(" << functionResNames[i] << ", dco::derivative(" << outputNames[i] << ".flat(i)));\n";
		file << "}\n";
		file << "}\n";
		file << functionResNames[i] << ".reshape({";
		for (size_t j = 0; j < outputs[i].Shape().size(); ++j) {
			if (j > 0) {
				file << ", ";
			}
			file << outputs[i].Shape()[j];
		}			
			file << "}); // Shape of outputs Tensor\n";
	}

	file << "}\n";



	// Main function
	file << "int main(void) {\n";
	file << "double h = 0.00001;\n";
	file << "// Graph inputs\n";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << inputs[i]->GetConstantString() ;
		file << "xt::xarray<" << inputs[i]->GetDataTypeAsString(true) << "> " << finiteInputNames[i]<< " = " << inputNames[i] << " + h; \n";
	}
	file << "// Graph outputs\n";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << outputs[i].GetVariableString(true) ;
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> " << finiteOutputNames[i] << ";\n";
		file << "xt::xarray<" << outputs[i].GetDataTypeAsString(true) << "> " << functionResNames[i] << ";\n";
	}
	file << "// Reference Values\n";
	for (size_t i = 0; i < references.size(); ++i) {
		file << references[i].GetVariableString(true) << "\n";
	}
	hasInAndOut = "";
	if (!inputs.empty() && !outputs.empty()) {
		hasInAndOut = ", ";
	}
	
	file << functionName << "(" << join(inputNames, ", ") << hasInAndOut << join(outputNames, ", ") << "); \n";
	file << functionName << "(" << join(finiteInputNames, ", ") << hasInAndOut << join(finiteOutputNames, ", ") << "); \n";
	for (size_t i = 0; i < outputNames.size(); ++i) {
		if (i < referenceNames.size() && i < finiteOutputNames.size()) {
			file <<  referenceNames[i] << " = (" << finiteOutputNames[i] << " - " << outputNames[i] << ")/h; \n";
		}
	}
	// tangent function call
	file << "df_fx_tangent(";
	for (size_t i = 0; i < inputs.size(); ++i) {
		file << inputNames[i];
		if (i < inputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << outputNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << ", ";
	for (size_t i = 0; i < outputs.size(); ++i) {
		file << functionResNames[i];
		if (i < outputs.size() - 1) {
			file << ", ";
		}
	}
	file << "); \n";

	// Compare Results
	for (size_t i = 0; i < outputNames.size(); ++i) {
		if (i < referenceNames.size()) {
			file << "if(" << functionResNames[i] << ".shape() !=" << referenceNames[i] << ".shape()){\n";
			file << "std::cout << \"Test failed because shape is not equal for function Result " << functionResNames[i] << ".\\n Expected: \\n\" << " << referenceNames[i] << " << \"\\n Actual: \\n\" << " << functionResNames[i] << " << std::endl;\n";
			file << "return 1; \n";
			file << "}\n";
			file << "for(std::size_t i = 0; i < "<< functionResNames[i]<< ".size(); ++i){\n";
			file << "if(std::abs( 1 - (" << functionResNames[i] << ".flat(i) / " << referenceNames[i] << ".flat(i))) > "<< accuracy << "){\n";
			file << "std::cout << \"Test failed for output " << functionResNames[i] << ".\\n Expected: \\n\" << " << referenceNames[i] << " << \"\\n Actual: \\n\" << " << functionResNames[i] << " << std::endl;\n";
			file << "return 1; \n";
			file << "}\n";
			file << "}\n";
		}
	}
	file << "std::cout << \"Test passed!\" << std::endl;\n";
	file << "return 0;\n";
	file << "}\n";

	file.close();

}
